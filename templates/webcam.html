{% extends "base.html" %}

{% block title %}Webcam Detection | Tomato AI{% endblock %}

{% block content %}
<style>
  .webcam-container {
    max-width: 1200px;
    margin: 20px auto;
    padding: 20px;
  }

  .video-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }

  .video-box {
    background: #f5f5f5;
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .video-box h3 {
    margin-top: 0;
    color: #333;
    font-size: 1.1em;
  }

  #webcam-video, #processed-canvas {
    width: 100%;
    border-radius: 8px;
    background: #000;
  }

  .controls {
    display: flex;
    gap: 10px;
    margin: 15px 0;
    flex-wrap: wrap;
  }

  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1em;
    transition: all 0.3s;
  }

  .btn-primary {
    background: #007aff;
    color: white;
  }

  .btn-primary:hover {
    background: #0056b3;
  }

  .btn-danger {
    background: #ff3b30;
    color: white;
  }

  .btn-success {
    background: #34c759;
    color: white;
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .prediction-display {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-top: 20px;
  }

  .prediction-result {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 15px;
  }

  .result-card {
    background: #f9fafb;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #007aff;
  }

  .result-card.healthy {
    border-color: #34c759;
  }

  .result-card.disease {
    border-color: #ff3b30;
  }

  .result-label {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 5px;
  }

  .result-value {
    font-size: 1.8em;
    font-weight: bold;
    color: #333;
  }

  .confidence-bar {
    height: 8px;
    background: #e0e0e0;
    border-radius: 4px;
    margin-top: 10px;
    overflow: hidden;
  }

  .confidence-fill {
    height: 100%;
    background: linear-gradient(90deg, #007aff, #34c759);
    transition: width 0.3s;
  }

  .status-indicator {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
  }

  .status-indicator.active {
    background: #34c759;
    animation: pulse 2s infinite;
  }

  .status-indicator.inactive {
    background: #8e8e93;
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  .settings {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-top: 20px;
  }

  .settings label {
    display: block;
    margin: 10px 0 5px;
    font-weight: 500;
    color: #333;
  }

  .settings select {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 1em;
  }

  @media (max-width: 768px) {
    .video-section {
      grid-template-columns: 1fr;
    }
    .prediction-result {
      grid-template-columns: 1fr;
    }
  }
</style>

<div class="webcam-container">
  <h1>üé• Real-time Webcam Disease Detection</h1>
  <p>H∆∞·ªõng l√° c√† chua v√†o camera ƒë·ªÉ ph√°t hi·ªán b·ªánh real-time</p>

  <div class="video-section">
    <div class="video-box">
      <h3><span class="status-indicator inactive" id="camera-status"></span>Camera Feed</h3>
      <video id="webcam-video" autoplay playsinline></video>
    </div>
    <div class="video-box">
      <h3>Detection Result</h3>
      <canvas id="processed-canvas"></canvas>
    </div>
  </div>

  <div class="controls">
    <button id="start-btn" class="btn btn-primary">‚ñ∂Ô∏è Start Camera</button>
    <button id="stop-btn" class="btn btn-danger" disabled>‚èπÔ∏è Stop</button>
    <button id="capture-btn" class="btn btn-success" disabled>üì∏ Capture & Analyze</button>
    <label style="margin-left: auto; display: flex; align-items: center;">
      <input type="checkbox" id="auto-detect" style="margin-right: 5px;">
      Auto-detect (continuous)
    </label>
  </div>

  <div class="prediction-display" id="prediction-display" style="display: none;">
    <h3>Latest Prediction</h3>
    <div class="prediction-result">
      <div class="result-card" id="class-card">
        <div class="result-label">Detected Class</div>
        <div class="result-value" id="pred-class">-</div>
      </div>
      <div class="result-card">
        <div class="result-label">Confidence</div>
        <div class="result-value" id="pred-confidence">-</div>
        <div class="confidence-bar">
          <div class="confidence-fill" id="confidence-fill" style="width: 0%"></div>
        </div>
      </div>
    </div>
    <div id="all-probabilities" style="margin-top: 15px;"></div>
  </div>

  <div class="settings">
    <h3>‚öôÔ∏è Settings</h3>
    <label>Model Architecture:</label>
    <select id="model-select">
      {% for model in models %}
      <option value="{{ model }}" {% if model == default_model %}selected{% endif %}>{{ model }}</option>
      {% endfor %}
    </select>

    <label>Preprocessing Pipeline:</label>
    <select id="pipeline-select">
      {% for pipeline in pipelines %}
      <option value="{{ pipeline }}" {% if pipeline == default_pipeline %}selected{% endif %}>{{ pipeline }}</option>
      {% endfor %}
    </select>

    <label>Detection Interval (ms):</label>
    <input type="number" id="interval-input" value="1000" min="200" max="5000" step="100" 
           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
  </div>
</div>

<script>
  const video = document.getElementById('webcam-video');
  const canvas = document.getElementById('processed-canvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const captureBtn = document.getElementById('capture-btn');
  const autoDetectCheckbox = document.getElementById('auto-detect');
  const cameraStatus = document.getElementById('camera-status');
  const predictionDisplay = document.getElementById('prediction-display');
  const modelSelect = document.getElementById('model-select');
  const pipelineSelect = document.getElementById('pipeline-select');
  const intervalInput = document.getElementById('interval-input');

  let stream = null;
  let autoDetectInterval = null;
  let isProcessing = false;

  // Start camera
  startBtn.addEventListener('click', async () => {
    try {
      stream = await navigator.mediaDevices.getUserMedia({ 
        video: { width: 640, height: 480 } 
      });
      video.srcObject = stream;
      
      startBtn.disabled = true;
      stopBtn.disabled = false;
      captureBtn.disabled = false;
      cameraStatus.classList.remove('inactive');
      cameraStatus.classList.add('active');

      // Set canvas size
      video.addEventListener('loadedmetadata', () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      });

      showToast('‚úì Camera started');
    } catch (error) {
      console.error('Error accessing camera:', error);
      showToast('‚úó Cannot access camera. Please grant permission.', 'error');
    }
  });

  // Stop camera
  stopBtn.addEventListener('click', () => {
    stopCamera();
    showToast('Camera stopped');
  });

  function stopCamera() {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      stream = null;
      video.srcObject = null;
    }
    if (autoDetectInterval) {
      clearInterval(autoDetectInterval);
      autoDetectInterval = null;
    }
    startBtn.disabled = false;
    stopBtn.disabled = true;
    captureBtn.disabled = true;
    cameraStatus.classList.remove('active');
    cameraStatus.classList.add('inactive');
  }

  // Capture and analyze
  captureBtn.addEventListener('click', () => {
    captureAndPredict();
  });

  // Auto-detect toggle
  autoDetectCheckbox.addEventListener('change', (e) => {
    if (e.target.checked) {
      const interval = parseInt(intervalInput.value) || 1000;
      autoDetectInterval = setInterval(() => {
        if (!isProcessing) {
          captureAndPredict();
        }
      }, interval);
      showToast('‚úì Auto-detect enabled');
    } else {
      if (autoDetectInterval) {
        clearInterval(autoDetectInterval);
        autoDetectInterval = null;
      }
      showToast('Auto-detect disabled');
    }
  });

  async function captureAndPredict() {
    if (!stream || isProcessing) return;

    isProcessing = true;
    captureBtn.textContent = '‚è≥ Processing...';
    captureBtn.disabled = true;

    try {
      // Draw current frame to canvas
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Convert canvas to base64
      const imageData = canvas.toDataURL('image/jpeg', 0.9);

      // Send to server
      const response = await fetch('{{ url_for('api_webcam_predict') }}', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          image: imageData,
          model: modelSelect.value,
          pipeline: pipelineSelect.value
        })
      });

      const data = await response.json();

      if (data.ok) {
        displayPrediction(data.prediction);
      } else {
        showToast('‚úó Prediction failed: ' + data.error, 'error');
      }

    } catch (error) {
      console.error('Error:', error);
      showToast('‚úó Connection error', 'error');
    } finally {
      isProcessing = false;
      captureBtn.textContent = 'üì∏ Capture & Analyze';
      if (!autoDetectCheckbox.checked) {
        captureBtn.disabled = false;
      }
    }
  }

  function displayPrediction(pred) {
    predictionDisplay.style.display = 'block';
    
    const predClass = pred.class;
    const confidence = (pred.confidence * 100).toFixed(1);

    document.getElementById('pred-class').textContent = predClass;
    document.getElementById('pred-confidence').textContent = confidence + '%';
    document.getElementById('confidence-fill').style.width = confidence + '%';

    // Update card styling
    const classCard = document.getElementById('class-card');
    classCard.className = 'result-card';
    if (predClass.toLowerCase().includes('healthy')) {
      classCard.classList.add('healthy');
    } else {
      classCard.classList.add('disease');
    }

    // Display all probabilities
    const allProbsDiv = document.getElementById('all-probabilities');
    allProbsDiv.innerHTML = '<strong>All Probabilities:</strong><br>';
    
    const sortedProbs = Object.entries(pred.all_probabilities)
      .sort((a, b) => b[1] - a[1]);
    
    sortedProbs.forEach(([cls, prob]) => {
      const percentage = (prob * 100).toFixed(1);
      allProbsDiv.innerHTML += `
        <div style="margin: 5px 0; padding: 5px; background: #f0f0f0; border-radius: 4px;">
          <strong>${cls}:</strong> ${percentage}%
          <div style="height: 4px; background: #ddd; border-radius: 2px; margin-top: 3px;">
            <div style="height: 100%; width: ${percentage}%; background: #007aff; border-radius: 2px;"></div>
          </div>
        </div>
      `;
    });

    // Smooth scroll
    predictionDisplay.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${type === 'error' ? '#ff3b30' : 'rgba(0, 0, 0, 0.8)'};
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
    `;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease-out';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    stopCamera();
  });
</script>

<style>
  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  @keyframes slideOut {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(100%);
      opacity: 0;
    }
  }
</style>
{% endblock %}
